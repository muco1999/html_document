<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Отправка местоположения в Telegram (прямо и с fallback)</title>
<style>
  body{font-family:Arial,Helvetica,sans-serif;background:#f6f8fb;display:flex;align-items:center;justify-content:center;height:100vh;margin:0}
  .card{background:#fff;padding:22px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.06);max-width:520px;width:92%;text-align:center}
  button{background:#25A0DA;color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer;font-size:15px}
  .status{margin-top:12px;color:#333;font-size:14px}
  .small{margin-top:8px;color:#777;font-size:12px}
</style>
</head>
<body>
  <div class="card">
    <h1>Отправить местоположение в Telegram</h1>
    <p>Клик — запрос геолокации → попытка отправить прямо в бот. Если не получится — откроется Telegram для подтверждения.</p>
    <button id="sendBtn">Отправить местоположение</button>
    <div id="status" class="status">Готово.</div>
    <div class="small">Токен виден в коде — использовать только для теста.</div>
  </div>

<script>
const botToken = "7869917177:AAFugiEYqSDo55XUYa7h7FSLaBkNVnoUA_w"; // ВНИМАНИЕ: виден в коде
const chatId = "6266166994"; // id чата или @channel_username
const statusEl = document.getElementById('status');
const btn = document.getElementById('sendBtn');

// Таймаут для операций fetch (ms)
function fetchWithTimeout(resource, options = {}, timeout = 8000) {
  return Promise.race([
    fetch(resource, options),
    new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
  ]);
}

async function trySendLocationViaBot(lat, lon) {
  // Попытка 1: sendLocation (покажет локацию как pin в чате)
  const sendLocationUrl = `https://api.telegram.org/bot${botToken}/sendLocation`;
  const body = new URLSearchParams({ chat_id: chatId, latitude: String(lat), longitude: String(lon) });

  try {
    const res = await fetchWithTimeout(sendLocationUrl, { method: 'POST', body }, 8000);
    if (res.ok) return { ok: true, method: 'sendLocation' };
    // если не ok — попытаемся sendMessage ниже
    return { ok: false, status: res.status, method: 'sendLocation' };
  } catch (err) {
    // ошибка (CORS/network/timeout)
    console.warn('sendLocation error', err);
    return { ok: false, error: err, method: 'sendLocation' };
  }
}

async function trySendMessageViaBot(text) {
  const sendMessageUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
  const body = new URLSearchParams({ chat_id: chatId, text });
  try {
    const res = await fetchWithTimeout(sendMessageUrl, { method: 'POST', body }, 8000);
    if (res.ok) return { ok: true, method: 'sendMessage' };
    return { ok: false, status: res.status, method: 'sendMessage' };
  } catch (err) {
    console.warn('sendMessage error', err);
    return { ok: false, error: err, method: 'sendMessage' };
  }
}

function openTelegramShare(text, mapUrl) {
  const urlParam = mapUrl ? encodeURIComponent(mapUrl) : '';
  const shareUrl = `https://t.me/share/url?url=${urlParam}&text=${encodeURIComponent(text)}`;
  // Открываем в новой вкладке, чтобы пользователь мог подтвердить отправку
  window.open(shareUrl, '_blank');
}

btn.addEventListener('click', async () => {
  if (!navigator.geolocation) {
    statusEl.textContent = 'Геолокация не поддерживается браузером.';
    return;
  }

  statusEl.textContent = 'Запрашиваем разрешение на геолокацию...';
  btn.disabled = true;

  navigator.geolocation.getCurrentPosition(async (pos) => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    const acc = pos.coords.accuracy;
    const mapUrl = `https://www.google.com/maps/search/?api=1&query=${lat},${lon}`;
    const messageText = `Местоположение:\nLatitude: ${lat}\nLongitude: ${lon}\nТочность: ${Math.round(acc)} м\nСсылка: ${mapUrl}`;

    statusEl.textContent = 'Пытаемся отправить локацию прямо в бот...';

    // 1) Попытка отправить как sendLocation
    const resLoc = await trySendLocationViaBot(lat, lon);
    if (resLoc.ok) {
      statusEl.textContent = 'Успешно отправлено в бот (sendLocation).';
      btn.disabled = false;
      return;
    }

    // 2) Если sendLocation не прошёл, пробуем отправить как текстовое сообщение
    statusEl.textContent = 'sendLocation не сработал, пробуем отправить текстом...';
    const resMsg = await trySendMessageViaBot(messageText);
    if (resMsg.ok) {
      statusEl.textContent = 'Успешно отправлено в бот (sendMessage).';
      btn.disabled = false;
      return;
    }

    // 3) Фоллбек: откроем Telegram share для ручного подтверждения
    statusEl.textContent = 'Не удалось отправить напрямую (CORS/сеть). Откроется Telegram для подтверждения отправки.';
    openTelegramShare(messageText, mapUrl);
    btn.disabled = false;

  }, (err) => {
    btn.disabled = false;
    if (err.code === 1) statusEl.textContent = 'Доступ к геолокации запрещён пользователем.';
    else if (err.code === 2) statusEl.textContent = 'Позиция недоступна.';
    else if (err.code === 3) statusEl.textContent = 'Превышено время ожидания.';
    else statusEl.textContent = 'Ошибка геолокации: ' + (err.message || err.code);
  }, { enableHighAccuracy: false, timeout: 15000, maximumAge: 0 });
});
</script>
</body>
</html>